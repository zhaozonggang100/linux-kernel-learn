### 1ã€æºç è·¯å¾„

- 1ã€kernelé©±åŠ¨

  `drivers/soc/qcom/watchdog_v2.c`

- 2ã€è®¾å¤‡æ ‘é…ç½®

```c
// arch/arm64/boot/dts/qcom/sm8150.dtsi
1855     wdog: qcom,wdt@17c10000{
1856         compatible = "qcom,msm-watchdog";
1857         reg = <0x17c10000 0x1000>;				// çœ‹é—¨ç‹—å¯„å­˜å™¨çš„èµ·å§‹åœ°å€å’Œå¤§å°
1858         reg-names = "wdt-base";
1859         interrupts = <0 0 0>, <0 1 0>;			// ä¸­æ–­ç±»å‹ï¼ˆæ¯ä¸ªå¤„ç†å™¨è‡ªå·±çš„ä¸­æ–­ï¼‰ã€ä¸­æ–­å·ã€ä¸­æ–­è§¦å‘æ–¹å¼ï¼ˆ0ï¼šä¸‹é™æ²¿ï¼‰
1860         qcom,bark-time = <11000>;				// ğŸ•å«æ—¶é—´ï¼š11s
1861         qcom,pet-time = <9360>;				// å–‚ğŸ•æ—¶é—´ï¼š9.36s
1862         qcom,ipi-ping;
1863         qcom,wakeup-enable;
1864         qcom,scandump-sizes = <0x10100 0x10100 0x10100 0x10100
1865         0x18100 0x18100 0x18100 0x18100>;
1866     };
```

### 2ã€kernelé©±åŠ¨

```cc
 39 #define MODULE_NAME "msm_watchdog"
 40 #define WDT0_ACCSCSSNBARK_INT 0
 41 #define TCSR_WDT_CFG    0x30
 42 #define WDT0_RST    0x04
 43 #define WDT0_EN     0x08
 44 #define WDT0_STS    0x0C
 45 #define WDT0_BARK_TIME  0x10
 46 #define WDT0_BITE_TIME  0x14
 47 
 48 #define WDOG_ABSENT 0
 49 
 50 #define EN      0
 51 #define UNMASKED_INT_EN 1
 52 
 53 #define MASK_SIZE       32
 54 #define SCM_SET_REGSAVE_CMD 0x2
 55 #define SCM_SVC_SEC_WDOG_DIS    0x7
 56 #define MAX_CPU_CTX_SIZE    2048
 57 
 58 static struct msm_watchdog_data *wdog_data;
 59 
 60 static int cpu_idle_pc_state[NR_CPUS];
 61 
 62 /*
 63  * user_pet_enable:
 64  *  Require userspace to write to a sysfs file every pet_time milliseconds.
 65  *  Disabled by default on boot.
 66  */
 67 struct msm_watchdog_data {
 68     unsigned int __iomem phys_base;			// çœ‹é—¨ç‹—å¯„å­˜å™¨å¯¹åº”çš„IOç‰©ç†èµ·å§‹åœ°å€
 69     size_t size;							// çœ‹é—¨ç‹—å¯„å­˜å™¨å çš„ç‰©ç†åœ°å€å¤§å°
 70     void __iomem *base;						// çœ‹é—¨ç‹—å¯„å­˜å™¨IOç‰©ç†åœ°å€æ˜ å°„åçš„å†…å­˜è™šæ‹Ÿåœ°å€
 71     void __iomem *wdog_absent_base;			// æœªä½¿ç”¨
 72     struct device *dev;						// çœ‹é—¨ç‹—é©±åŠ¨å¯¹åº”çš„è®¾å¤‡æˆå‘˜
 73     unsigned int pet_time;					// å–‚ç‹—æ—¶é—´é—´éš”9.36s
 74     unsigned int bark_time;					// ğŸ•å«è¶…æ—¶æ—¶é—´11s
 75     unsigned int bark_irq;					// ğŸ•å«ä¸­æ–­å·ï¼š0
 76     unsigned int bite_irq;					// ğŸ•å’¬ä¸­æ–­å·ï¼š1	
 77     bool do_ipi_ping;						// æ”¯æŒå–‚ç‹—æ—¶pingå…¶ä»–cpu
 78     bool wakeup_irq_enable;					// æ”¯æŒä¼‘çœ å”¤é†’æ—¶çœ‹é—¨ç‹—åœæ­¢å’Œå¯åŠ¨
 79     unsigned long long last_pet;			// ä¸Šæ¬¡å–‚ç‹—æ—¶é—´
  80     unsigned int min_slack_ticks;			
 81     unsigned long long min_slack_ns;
 82     void *scm_regsave;						// è·³è½¬å®‰å…¨æµ‹ä¿å­˜å¯„å­˜å™¨
 83     cpumask_t alive_mask;					// æ´»ç€çš„CPU
 84     struct mutex disable_lock;
 85     bool irq_ppi;							// ç‹—å«çš„ä¸­æ–­æ˜¯å¦æ˜¯æ¯CPUå…±äº«çš„
 86     struct msm_watchdog_data __percpu **wdog_cpu_dd;
 87     struct notifier_block panic_blk;		// æ³¨å†Œåˆ°panicå­ç³»ç»Ÿï¼Œpanicæ—¶è°ƒç”¨å›è°ƒå‡½æ•°è§¦å‘ç‹—å’¬
 88 
 89     bool enabled;
 90     bool user_pet_enabled;
 91 
 92     struct task_struct *watchdog_task;		// çœ‹é—¨ç‹—çº¿ç¨‹
 93     struct timer_list pet_timer;			// å–‚ğŸ•å®šæ—¶å™¨
 94     wait_queue_head_t pet_complete;
 95 
 96     bool timer_expired;						// å–‚ç‹—å®šæ—¶å™¨æ˜¯å¦è¶…æ—¶
 97     bool user_pet_complete;
 98     unsigned long long timer_fired;
 99     unsigned long long thread_start;
100     unsigned long long ping_start[NR_CPUS];
101     unsigned long long ping_end[NR_CPUS];
102     unsigned int cpu_scandump_sizes[NR_CPUS];
103 
104     /* When single buffer is used to collect Scandump */
105     unsigned int scandump_size;
106 };
107 
108 /*
109  * On the kernel command line specify
110  * watchdog_v2.enable=1 to enable the watchdog
111  * By default watchdog is turned on
112  */
113 static int enable = 1;
114 module_param(enable, int, 0000);
115 
116 /*
117  * On the kernel command line specify
118  * watchdog_v2.WDT_HZ=<clock val in HZ> to set Watchdog
119  * ticks. By default it is set to 32765.
120  */
121 static long WDT_HZ = 32765;
122 module_param(WDT_HZ, long, 0000);
123 
124 /*
125  * Watchdog ipi optimization:
126  * Does not ping cores in low power mode at pet time to save power.
127  * This feature is enabled by default.
128  *
129  * On the kernel command line specify
130  * watchdog_v2.ipi_en=1 to disable this optimization.
131  * Or, can be turned off, by enabling CONFIG_QCOM_WDOG_IPI_ENABLE.
132  */
133 #ifdef CONFIG_QCOM_WDOG_IPI_ENABLE
134 #define IPI_CORES_IN_LPM 1
135 #else
136 #define IPI_CORES_IN_LPM 0
137 #endif
138 
139 static int ipi_en = IPI_CORES_IN_LPM;
140 module_param(ipi_en, int, 0444);
141 
142 static void dump_cpu_alive_mask(struct msm_watchdog_data *wdog_dd)
143 {
144     static char alive_mask_buf[MASK_SIZE];
145 
146     scnprintf(alive_mask_buf, MASK_SIZE, "%*pb1", cpumask_pr_args(
147                 &wdog_dd->alive_mask));
148     dev_info(wdog_dd->dev, "cpu alive mask from last pet %s\n",
149                 alive_mask_buf);
150 }
151 
152 static int msm_watchdog_suspend(struct device *dev)
153 {
154     struct msm_watchdog_data *wdog_dd =
155             (struct msm_watchdog_data *)dev_get_drvdata(dev);
156     if (!enable)
157         return 0;
158     __raw_writel(1, wdog_dd->base + WDT0_RST);
159     if (wdog_dd->wakeup_irq_enable) {
160         /* Make sure register write is complete before proceeding */
161         mb();
162         wdog_dd->last_pet = sched_clock();	// è®°å½•ä¸Šæ¬¡çš„å–‚ç‹—æ—¶é—´
163         return 0;
164     }
165     __raw_writel(0, wdog_dd->base + WDT0_EN);	// å…³é—­çœ‹é—¨ç‹—
166     /* Make sure watchdog is suspended before setting enable */
167     mb();
168     wdog_dd->enabled = false;
169     wdog_dd->last_pet = sched_clock();
170     return 0;
171 }
172 
173 static int msm_watchdog_resume(struct device *dev)
174 {
175     struct msm_watchdog_data *wdog_dd =
176             (struct msm_watchdog_data *)dev_get_drvdata(dev);
177     if (!enable)
178         return 0;
179     if (wdog_dd->wakeup_irq_enable) {
180         __raw_writel(1, wdog_dd->base + WDT0_RST);	// å¤ä½çœ‹é—¨ç‹—
181         /* Make sure register write is complete before proceeding */
182         mb();
183         wdog_dd->last_pet = sched_clock();
184         return 0;
185     }
186     __raw_writel(1, wdog_dd->base + WDT0_EN);		// ä½¿èƒ½çœ‹é—¨ç‹—
187     __raw_writel(1, wdog_dd->base + WDT0_RST);		// å¤ä½çœ‹é—¨ç‹—
188     /* Make sure watchdog is reset before setting enable */
189     mb();
190     wdog_dd->enabled = true;
191     wdog_dd->last_pet = sched_clock();
192     return 0;
193 }
194 
195 static int panic_wdog_handler(struct notifier_block *this,
196                   unsigned long event, void *ptr)
197 {
198     struct msm_watchdog_data *wdog_dd = container_of(this,
199                 struct msm_watchdog_data, panic_blk);
200     if (panic_timeout == 0) {
201         __raw_writel(0, wdog_dd->base + WDT0_EN);	// å…³é—­çœ‹é—¨ç‹—ï¼Œç³»ç»Ÿhungä½ä¸åŠ¨
202         /* Make sure watchdog is enabled before notifying the caller */
203         mb();
204     } else {
    		// å¦‚æœè®¾ç½®äº†CONFIG_PANIC_TIMEOUTä¸ä¸º0
205         __raw_writel(WDT_HZ * (panic_timeout + 10),
206                 wdog_dd->base + WDT0_BARK_TIME);
207         __raw_writel(WDT_HZ * (panic_timeout + 10),
208                 wdog_dd->base + WDT0_BITE_TIME);
209         __raw_writel(1, wdog_dd->base + WDT0_RST);
210     }
211     return NOTIFY_DONE;
212 }
213 
214 static void wdog_disable(struct msm_watchdog_data *wdog_dd)
215 {
216     __raw_writel(0, wdog_dd->base + WDT0_EN);
217     /* Make sure watchdog is disabled before proceeding */
218     mb();
219     if (wdog_dd->irq_ppi) {
220         disable_percpu_irq(wdog_dd->bark_irq);
221         free_percpu_irq(wdog_dd->bark_irq, wdog_dd->wdog_cpu_dd);
222     } else
223         devm_free_irq(wdog_dd->dev, wdog_dd->bark_irq, wdog_dd);
224     enable = 0;
225     /*Ensure all cpus see update to enable*/
226     smp_mb();
227     atomic_notifier_chain_unregister(&panic_notifier_list,
228                         &wdog_dd->panic_blk);
229     del_timer_sync(&wdog_dd->pet_timer);
230     /* may be suspended after the first write above */
231     __raw_writel(0, wdog_dd->base + WDT0_EN);
232     /* Make sure watchdog is disabled before setting enable */
233     mb();
234     wdog_dd->enabled = false;
235     pr_info("MSM Apps Watchdog deactivated.\n");
236 }
237 
238 static ssize_t wdog_disable_get(struct device *dev,
239                 struct device_attribute *attr, char *buf)
240 {
241     int ret;
242     struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
243 
244     mutex_lock(&wdog_dd->disable_lock);
245     ret = snprintf(buf, PAGE_SIZE, "%d\n", enable == 0 ? 1 : 0);
246     mutex_unlock(&wdog_dd->disable_lock);
247     return ret;
248 }
249 
250 static ssize_t wdog_disable_set(struct device *dev,
251                 struct device_attribute *attr,
252                 const char *buf, size_t count)
253 {
254     int ret;
255     u8 disable;
256     struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
257 
258     ret = kstrtou8(buf, 10, &disable);
259     if (ret) {
260         dev_err(wdog_dd->dev, "invalid user input\n");
261         return ret;
262     }
263     if (disable == 1) {
264         mutex_lock(&wdog_dd->disable_lock);
265         if (enable == 0) {
266             pr_info("MSM Apps Watchdog already disabled\n");
267             mutex_unlock(&wdog_dd->disable_lock);
268             return count;
269         }
270         disable = 1;
271         if (!is_scm_armv8()) {
    			// Linuxç«¯å…³é—­çœ‹é—¨ç‹—ï¼Œéœ€è¦é€šçŸ¥TEEç«¯å…³é—­ç‹—å’¬ä¸­æ–­
272             ret = scm_call(SCM_SVC_BOOT, SCM_SVC_SEC_WDOG_DIS,
273                        &disable, sizeof(disable), NULL, 0);
274         } else {
275             struct scm_desc desc = {0};
276 
277             desc.args[0] = 1;
278             desc.arginfo = SCM_ARGS(1);
279             ret = scm_call2(SCM_SIP_FNID(SCM_SVC_BOOT,
280                     SCM_SVC_SEC_WDOG_DIS), &desc);
281         }
282         if (ret) {
283             dev_err(wdog_dd->dev,
284                     "Failed to deactivate secure wdog\n");
285             mutex_unlock(&wdog_dd->disable_lock);
286             return -EIO;
287         }
288         wdog_disable(wdog_dd);
289         mutex_unlock(&wdog_dd->disable_lock);
290     } else {
291         pr_err("invalid operation, only disable = 1 supported\n");
292         return -EINVAL;
293     }
294     return count;
295 }
296 
297 static DEVICE_ATTR(disable, 0600, wdog_disable_get, wdog_disable_set);
298 
299 /*
300  * Userspace Watchdog Support:
301  * Write 1 to the "user_pet_enabled" file to enable hw support for a
302  * userspace watchdog.
303  * Userspace is required to pet the watchdog by continuing to write 1
304  * to this file in the expected interval.
305  * Userspace may disable this requirement by writing 0 to this same
306  * file.
307  */
308 static void __wdog_user_pet(struct msm_watchdog_data *wdog_dd)
309 {
310     wdog_dd->user_pet_complete = true;
311     wake_up(&wdog_dd->pet_complete);
312 }
313 
314 static ssize_t wdog_user_pet_enabled_get(struct device *dev,
315                 struct device_attribute *attr, char *buf)
316 {
317     int ret;
318     struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
319 
320     ret = snprintf(buf, PAGE_SIZE, "%d\n",
321             wdog_dd->user_pet_enabled);
322     return ret;
323 }
324 
325 static ssize_t wdog_user_pet_enabled_set(struct device *dev,
326                 struct device_attribute *attr,
327                 const char *buf, size_t count)
328 {
329     int ret;
330     struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
331 
332     ret = strtobool(buf, &wdog_dd->user_pet_enabled);
333     if (ret) {
334         dev_err(wdog_dd->dev, "invalid user input\n");
335         return ret;
336     }
337 
338     __wdog_user_pet(wdog_dd);
339 
340     return count;
341 }
342 
343 static DEVICE_ATTR(user_pet_enabled, 0600, wdog_user_pet_enabled_get,
344                         wdog_user_pet_enabled_set);
345 
346 static ssize_t wdog_pet_time_get(struct device *dev,
347                 struct device_attribute *attr, char *buf)
348 {
349     int ret;
350     struct msm_watchdog_data *wdog_dd = dev_get_drvdata(dev);
351 
352     ret = snprintf(buf, PAGE_SIZE, "%d\n", wdog_dd->pet_time);
353     return ret;
354 }
355 
356 static DEVICE_ATTR(pet_time, 0400, wdog_pet_time_get, NULL);
357 
    // å–‚ç‹—
358 static void pet_watchdog(struct msm_watchdog_data *wdog_dd)
359 {
360     int slack, i, count, prev_count = 0;
361     unsigned long long time_ns;
362     unsigned long long slack_ns;
363     unsigned long long bark_time_ns = wdog_dd->bark_time * 1000000ULL;
364 
365     for (i = 0; i < 2; i++) {
366         count = (__raw_readl(wdog_dd->base + WDT0_STS) >> 1) & 0xFFFFF;
367         if (count != prev_count) {
368             prev_count = count;
369             i = 0;
370         }
371     }
372     slack = ((wdog_dd->bark_time * WDT_HZ) / 1000) - count;
373     if (slack < wdog_dd->min_slack_ticks)
374         wdog_dd->min_slack_ticks = slack;
375     __raw_writel(1, wdog_dd->base + WDT0_RST);	// é‡æ–°å¤ä½çœ‹é—¨ç‹—ï¼Œ11såç‹—å«å®šæ—¶å™¨è¶…æ—¶
376     time_ns = sched_clock();
377     slack_ns = (wdog_dd->last_pet + bark_time_ns) - time_ns;
378     if (slack_ns < wdog_dd->min_slack_ns)
379         wdog_dd->min_slack_ns = slack_ns;
380     wdog_dd->last_pet = time_ns;
381 }
382 
383 static void keep_alive_response(void *info)
384 {
385     int cpu = smp_processor_id();
386     struct msm_watchdog_data *wdog_dd = (struct msm_watchdog_data *)info;
387 
388     cpumask_set_cpu(cpu, &wdog_dd->alive_mask);
389     wdog_dd->ping_end[cpu] = sched_clock();
390     /* Make sure alive mask is cleared and set in order */
391     smp_mb();
392 }
393 
394 /*
395  * If this function does not return, it implies one of the
396  * other cpu's is not responsive.
397  */
398 static void ping_other_cpus(struct msm_watchdog_data *wdog_dd)
399 {
400     int cpu;
401 
402     cpumask_clear(&wdog_dd->alive_mask);
403     /* Make sure alive mask is cleared and set in order */
404     smp_mb();
405     for_each_cpu(cpu, cpu_online_mask) {
406         if (!cpu_idle_pc_state[cpu] && !cpu_isolated(cpu)) {
407             wdog_dd->ping_start[cpu] = sched_clock();
408             smp_call_function_single(cpu, keep_alive_response,
409                          wdog_dd, 1);
410         }
411     }
412 }
413 
414 static void pet_task_wakeup(unsigned long data)
415 {
416     struct msm_watchdog_data *wdog_dd =
417         (struct msm_watchdog_data *)data;
    	// å°†çœ‹é—¨ç‹—çº¿ç¨‹çš„ç­‰å¾…å”¤é†’æ¡ä»¶ç½®ä¸ºtrueï¼Œä¸ç„¶å”¤é†’çº¿ç¨‹çº¿ç¨‹åˆ¤æ–­æ¡ä»¶ä¸æ»¡è¶³æ¥ç€sleep
418     wdog_dd->timer_expired = true;
419     wdog_dd->timer_fired = sched_clock();
    	// å”¤é†’msm-watchdogå–‚ç‹—çº¿ç¨‹ï¼Œå–‚ç‹—çº¿ç¨‹åœ¨å”¤é†’ä¹‹å‰ä¸€ç›´é˜»å¡åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šï¼Œçº¿ç¨‹ä¸€ç›´å¤„äºSçŠ¶æ€ï¼ˆå¯è¢«æ‰“æ–­çš„ä¸­æ–­ï¼‰
420     wake_up(&wdog_dd->pet_complete);
421 }
422 
423 static __ref int watchdog_kthread(void *arg)
424 {
425     struct msm_watchdog_data *wdog_dd =
426         (struct msm_watchdog_data *)arg;
427     unsigned long delay_time = 0;
428     struct sched_param param = {.sched_priority = MAX_RT_PRIO-1};
429     int ret, cpu;
430 
431     sched_setscheduler(current, SCHED_FIFO, &param);
432     while (!kthread_should_stop()) {
433         do {
    			// å¾ªç¯ç­‰å¾…pet_timerå”¤é†’,ç­‰å¾…çš„æ¡ä»¶æ˜¯wdog_dd->timer_expiredä¸ºtrue
434             ret = wait_event_interruptible(wdog_dd->pet_complete,
435                         wdog_dd->timer_expired);
436         } while (ret != 0);
437 
438         wdog_dd->thread_start = sched_clock();
439         for_each_cpu(cpu, cpu_present_mask)
440             wdog_dd->ping_start[cpu] = wdog_dd->ping_end[cpu] = 0;
441 
    		// ç­‰å¾…æ‰€æœ‰cpuçš„å“åº”
442         if (wdog_dd->do_ipi_ping)
443             ping_other_cpus(wdog_dd);
444 
    		// ç­‰å¾…ç”¨æˆ·ç©ºé—´å†™æ ‡å¿—ä½ï¼Œä¸èµ·ä½œç”¨
445         do {
446             ret = wait_event_interruptible(wdog_dd->pet_complete,
447                         wdog_dd->user_pet_complete);
448         } while (ret != 0);
449 
450         wdog_dd->timer_expired = false;
451         wdog_dd->user_pet_complete = !wdog_dd->user_pet_enabled;
452 
453         if (enable) {
    			// è®¾ç½®ä¸‹æ¬¡å–‚ç‹—æ—¶é—´ä¸ºï¼šå½“å‰æ—¶é—´+10s
454             delay_time = msecs_to_jiffies(wdog_dd->pet_time);
    			// å–‚ç‹—ï¼Œå°±æ˜¯å¤ä½çœ‹é—¨ç‹—
455             pet_watchdog(wdog_dd);
456         }
457         /* Check again before scheduling
458          * Could have been changed on other cpu
459          */
    		// å–‚ç‹—å®šæ—¶å™¨åˆ°æœŸï¼Œé‡æ–°æ·»åŠ å®šæ—¶å™¨ï¼Œä¸ç„¶å®šæ—¶å™¨å°±ä¸ä¼šå†è§¦å‘ï¼Œè¯¥çº¿ç¨‹å°±æ°¸è¿œä¼‘çœ åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šäº†
460         mod_timer(&wdog_dd->pet_timer, jiffies + delay_time);
461     }
462     return 0;
463 }
464 
465 static int wdog_cpu_pm_notify(struct notifier_block *self,
466                   unsigned long action, void *v)
467 {
468     int cpu;
469 
470     cpu = raw_smp_processor_id();
471 
472     switch (action) {
473     case CPU_PM_ENTER:
474         cpu_idle_pc_state[cpu] = 1;
475         break;
476     case CPU_PM_ENTER_FAILED:
477     case CPU_PM_EXIT:
478         cpu_idle_pc_state[cpu] = 0;
479         break;
480     }
481 
482     return NOTIFY_OK;
483 }
484 
485 static struct notifier_block wdog_cpu_pm_nb = {
486     .notifier_call = wdog_cpu_pm_notify,
487 };
488 
489 static int msm_watchdog_remove(struct platform_device *pdev)
490 {
491     struct msm_watchdog_data *wdog_dd =
492             (struct msm_watchdog_data *)platform_get_drvdata(pdev);
493 
494     if (!ipi_en)
495         cpu_pm_unregister_notifier(&wdog_cpu_pm_nb);
496 
497     mutex_lock(&wdog_dd->disable_lock);
498     if (enable)
499         wdog_disable(wdog_dd);
500 
501     mutex_unlock(&wdog_dd->disable_lock);
502     device_remove_file(wdog_dd->dev, &dev_attr_disable);
503     if (wdog_dd->irq_ppi)
504         free_percpu(wdog_dd->wdog_cpu_dd);
505     dev_info(wdog_dd->dev, "MSM Watchdog Exit - Deactivated\n");
506     del_timer_sync(&wdog_dd->pet_timer);
507     kthread_stop(wdog_dd->watchdog_task);
508     kfree(wdog_dd);
509     return 0;
510 }
511 
512 void msm_trigger_wdog_bite(void)
513 {
514     if (!wdog_data)
515         return;
516     pr_info("Causing a watchdog bite!");
    	// ç‹—å«ä¹‹åå†™1ç›¸å½“äºç«‹åˆ»è§¦å‘ç‹—å’¬ï¼ˆè¿™é‡Œçš„1ä¸æ˜¯1s,è€Œæ˜¯çœ‹é—¨ç‹—çš„1HZ 1/32765ï¼‰ï¼Œè¿™é‡Œä¼šç«‹åˆ»è§¦å‘ğŸ•biteä¸­æ–­ï¼Œè¿™ä¸ªä¸­æ–­åœ¨Linuxé‡Œæ²¡æœ‰æ³¨å†Œï¼Œå¯èƒ½åœ¨TEEç«¯æ³¨å†Œäº†
517     __raw_writel(1, wdog_data->base + WDT0_BITE_TIME);
518     /* Mke sure bite time is written before we reset */
519     mb();
520     __raw_writel(1, wdog_data->base + WDT0_RST);
521     /* Make sure we wait only after reset */
522     mb();
523     /* Delay to make sure bite occurs */
524     mdelay(10000);
525     pr_err("Wdog - STS: 0x%x, CTL: 0x%x, BARK TIME: 0x%x, BITE TIME: 0x%x",
526         __raw_readl(wdog_data->base + WDT0_STS),
527         __raw_readl(wdog_data->base + WDT0_EN),
528         __raw_readl(wdog_data->base + WDT0_BARK_TIME),
529         __raw_readl(wdog_data->base + WDT0_BITE_TIME));
530 }
531 
    // æ­¤æ—¶è·ç¦»ä¸Šæ¬¡å–‚ç‹—è¾¾åˆ°11sï¼ŒğŸ•å«çœ‹é—¨ç‹—å®šæ—¶å™¨è¶…æ—¶ï¼Œè§¦å‘ğŸ•å«ä¸­æ–­å¤„ç†å‡½æ•°wdog_bark_handler
532 static irqreturn_t wdog_bark_handler(int irq, void *dev_id)
533 {
534     struct msm_watchdog_data *wdog_dd = (struct msm_watchdog_data *)dev_id;
535     unsigned long nanosec_rem;
536     unsigned long long t = sched_clock();
537 
538     nanosec_rem = do_div(t, 1000000000);
539     dev_info(wdog_dd->dev, "Watchdog bark! Now = %lu.%06lu\n",
540             (unsigned long) t, nanosec_rem / 1000);
541 
542     nanosec_rem = do_div(wdog_dd->last_pet, 1000000000);
543     dev_info(wdog_dd->dev, "Watchdog last pet at %lu.%06lu\n",
544             (unsigned long) wdog_dd->last_pet, nanosec_rem / 1000);
545     if (wdog_dd->do_ipi_ping)
546         dump_cpu_alive_mask(wdog_dd);	// æ‰“å°ä¸Šæ¬¡å–‚ç‹—æ—¶æ´»ç€çš„CPUæœ‰å“ªäº›
547     msm_trigger_wdog_bite();
548     panic("Failed to cause a watchdog bite! - Falling back to kernel panic!");
549     return IRQ_HANDLED;
550 }
551 
    /*
    	æ¯cpuå…±äº«ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨wdog_bark_handler
    */
552 static irqreturn_t wdog_ppi_bark(int irq, void *dev_id)
553 {
554     struct msm_watchdog_data *wdog_dd =
555             *(struct msm_watchdog_data **)(dev_id);
556     return wdog_bark_handler(irq, wdog_dd);
557 }
558 
	/*
	 	å‘teeç«¯æ³¨å†ŒLinuxç«¯çš„çœ‹é—¨ç‹—
     
      	TAå¯èƒ½ä¼šå°†1å·ç‹—å’¬ä¸­æ–­æ³¨å†Œä¸ºå¿«é€Ÿä¸­æ–­,å½“ç‹—å«ä¸­æ–­ä¸­å¿«é€Ÿè§¦å‘ç‹—å’¬ä¹‹åï¼Œteeç«¯æ£€æµ‹åˆ°ç‹—å’¬ï¼Œæ¥ç€dump cpuä¿¡æ¯ï¼Œæ ¹æ®userè¿˜æ˜¯userdebug	
     		userç›´æ¥å»è§¦å‘pmicæ‹‰power keyæ‰§è¡Œwarm reboot
			userdebugä¼šwarm rebootä¹‹ååœ¨xblä¸­è¿›å…¥ramdumpæ¨¡å¼
	 * */
559 static void configure_bark_dump(struct msm_watchdog_data *wdog_dd)
560 {
561     int ret;
562     struct msm_dump_entry dump_entry;
563     struct msm_dump_data *cpu_data;
564     int cpu;
565     void *cpu_buf;
566 
567     cpu_data = kcalloc(num_present_cpus(), sizeof(struct msm_dump_data),
568                                 GFP_KERNEL);
569     if (!cpu_data)
570         goto out0;
571 
572     cpu_buf = kcalloc(num_present_cpus(), MAX_CPU_CTX_SIZE, GFP_KERNEL);
573     if (!cpu_buf)
574         goto out1;
575 
576     for_each_cpu(cpu, cpu_present_mask) {
577         cpu_data[cpu].addr = virt_to_phys(cpu_buf +
578                         cpu * MAX_CPU_CTX_SIZE);
579         cpu_data[cpu].len = MAX_CPU_CTX_SIZE;
580         snprintf(cpu_data[cpu].name, sizeof(cpu_data[cpu].name),
581             "KCPU_CTX%d", cpu);
582         dump_entry.id = MSM_DUMP_DATA_CPU_CTX + cpu;
583         dump_entry.addr = virt_to_phys(&cpu_data[cpu]);
584         ret = msm_dump_data_register(MSM_DUMP_TABLE_APPS,
585                          &dump_entry);
586         /*
587          * Don't free the buffers in case of error since
588          * registration may have succeeded for some cpus.
589          */
590         if (ret)
591             pr_err("cpu %d reg dump setup failed\n", cpu);
592     }
593 
594     return;
595 out1:
596     kfree(cpu_data);
597 out0:
598     return;
599 }
600 
601 static void register_scan_dump(struct msm_watchdog_data *wdog_dd)
602 {
603     static void *dump_addr;
604     int ret;
605     struct msm_dump_entry dump_entry;
606     struct msm_dump_data *dump_data;
607 
608     dump_data = kzalloc(sizeof(struct msm_dump_data), GFP_KERNEL);
609     if (!dump_data)
610         return;
611     dump_addr = kzalloc(wdog_dd->scandump_size, GFP_KERNEL);
612     if (!dump_addr)
613         goto err0;
614 
615     dump_data->addr = virt_to_phys(dump_addr);
616     dump_data->len = wdog_dd->scandump_size;
617     strlcpy(dump_data->name, "KSCANDUMP", sizeof(dump_data->name));
618 
619     dump_entry.id = MSM_DUMP_DATA_SCANDUMP;
620     dump_entry.addr = virt_to_phys(dump_data);
621     ret = msm_dump_data_register(MSM_DUMP_TABLE_APPS, &dump_entry);
622     if (ret) {
623         pr_err("Registering scandump region failed\n");
624         goto err1;
625     }
626     return;
627 err1:
628     kfree(dump_addr);
629 err0:
630     kfree(dump_data);
631 }
632 
633 static void configure_scandump(struct msm_watchdog_data *wdog_dd)
634 {
635     int ret;
636     struct msm_dump_entry dump_entry;
637     struct msm_dump_data *cpu_data;
638     int cpu;
639     static dma_addr_t dump_addr;
640     static void *dump_vaddr;
641     unsigned int scandump_size;
642 
643     if (wdog_dd->scandump_size) {
644         register_scan_dump(wdog_dd);
645         return;
646     }
647 
648     for_each_cpu(cpu, cpu_present_mask) {
649         scandump_size = wdog_dd->cpu_scandump_sizes[cpu];
650         cpu_data = devm_kzalloc(wdog_dd->dev,
651                     sizeof(struct msm_dump_data),
652                     GFP_KERNEL);
653         if (!cpu_data)
654             continue;
655 
656         dump_vaddr = (void *) dma_alloc_coherent(wdog_dd->dev,
657                              scandump_size,
658                              &dump_addr,
659                              GFP_KERNEL);
660         if (!dump_vaddr) {
661             dev_err(wdog_dd->dev, "Couldn't get memory for dump\n");
662             continue;
663         }
664         memset(dump_vaddr, 0x0, scandump_size);
665 
666         cpu_data->addr = dump_addr;
667         cpu_data->len = scandump_size;
668         snprintf(cpu_data->name, sizeof(cpu_data->name),
669             "KSCANDUMP%d", cpu);
670         dump_entry.id = MSM_DUMP_DATA_SCANDUMP_PER_CPU + cpu;
671         dump_entry.addr = virt_to_phys(cpu_data);
672         ret = msm_dump_data_register(MSM_DUMP_TABLE_APPS,
673                          &dump_entry);
674         if (ret) {
675             dev_err(wdog_dd->dev, "Dump setup failed, id = %d\n",
676                 MSM_DUMP_DATA_SCANDUMP_PER_CPU + cpu);
677             dma_free_coherent(wdog_dd->dev, scandump_size,
678                       dump_vaddr,
679                       dump_addr);
680             devm_kfree(wdog_dd->dev, cpu_data);
681         }
682     }
683 }
684 
685 static int init_watchdog_sysfs(struct msm_watchdog_data *wdog_dd)
686 {
687     int error = 0;
688 
689     error |= device_create_file(wdog_dd->dev, &dev_attr_disable);
690 
691     if (of_property_read_bool(wdog_dd->dev->of_node,
692                     "qcom,userspace-watchdog")) {
693         error |= device_create_file(wdog_dd->dev, &dev_attr_pet_time);
694         error |= device_create_file(wdog_dd->dev,
695                         &dev_attr_user_pet_enabled);
696     
697 
698     if (error)
699         dev_err(wdog_dd->dev, "cannot create sysfs attribute\n");
700 
701     return error;
702 }
703 
704 static void init_watchdog_data(struct msm_watchdog_data *wdog_dd)
705 {
706     unsigned long delay_time;
707     uint32_t val;
708     u64 timeout;
709     int ret;
710 
711     /*
712      * Disable the watchdog for cluster 1 so that cluster 0 watchdog will
713      * be mapped to the entire sub-system.
714      */
    	// è¿›ä¸å»
715     if (wdog_dd->wdog_absent_base)
716         __raw_writel(2, wdog_dd->wdog_absent_base + WDOG_ABSENT);
717 
718     if (wdog_dd->irq_ppi) {
719         wdog_dd->wdog_cpu_dd = alloc_percpu(struct msm_watchdog_data *);
720         if (!wdog_dd->wdog_cpu_dd) {
721             dev_err(wdog_dd->dev, "fail to allocate cpu data\n");
722             return;
723         }
724         *raw_cpu_ptr(wdog_dd->wdog_cpu_dd) = wdog_dd;
    		// ç”³è¯·æ¯ä¸ªcpuéƒ½èƒ½å“åº”çš„ç‹—å«ä¸­æ–­ï¼Œwdog_ppi_barkæ˜¯ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œåœ¨çœ‹é—¨ç‹—è¶…è®¡æ•°å™¨æº¢å‡ºæ—¶è§¦å‘ä¸­æ–­è°ƒç”¨
725         ret = request_percpu_irq(wdog_dd->bark_irq, wdog_ppi_bark,
726                     "apps_wdog_bark",
727                     wdog_dd->wdog_cpu_dd);
728         if (ret) {
729             dev_err(wdog_dd->dev, "failed to request bark irq\n");
730             free_percpu(wdog_dd->wdog_cpu_dd);
731             return;
732         }
733     } else {
734         ret = devm_request_irq(wdog_dd->dev, wdog_dd->bark_irq,
735                 wdog_bark_handler, IRQF_TRIGGER_RISING,
736                         "apps_wdog_bark", wdog_dd);
737         if (ret) {
738             dev_err(wdog_dd->dev, "failed to request bark irq\n");
739             return;
740         }
741     }
742     delay_time = msecs_to_jiffies(wdog_dd->pet_time);	// 9.56så¯¹åº”çš„jiffies
743     wdog_dd->min_slack_ticks = UINT_MAX;
744     wdog_dd->min_slack_ns = ULLONG_MAX;
    	// é…ç½®minidump
745     configure_scandump(wdog_dd);
746     configure_bark_dump(wdog_dd);
747     timeout = (wdog_dd->bark_time * WDT_HZ)/1000;	// 11*32765
    	// è®¾ç½®ğŸ•å«çš„è¶…æ—¶æ—¶é—´æ˜¯11sï¼Œè¶…æ—¶è§¦å‘æ‰§è¡Œwdog_ppi_barkä¸­æ–­å¤„ç†å‡½æ•°
748     __raw_writel(timeout, wdog_dd->base + WDT0_BARK_TIME);
    	// è®¾ç½®ğŸ•å’¬çš„è¶…æ—¶æ—¶é—´æ˜¯14sï¼Œå¯¹åº”çš„è¶…æ—¶ä¸­æ–­æ²¡æœ‰åœ¨Linuxä¸­æ³¨å†Œï¼Œå¯èƒ½åœ¨TEEç«¯æ³¨å†Œä¸ºå¿«é€Ÿä¸­æ–­
749     __raw_writel(timeout + 3*WDT_HZ, wdog_dd->base + WDT0_BITE_TIME);
750 
    	// panicæ—¶é€šè¿‡é€šçŸ¥å­ç³»ç»Ÿè°ƒç”¨åˆ°panic_wdog_handler
751     wdog_dd->panic_blk.notifier_call = panic_wdog_handler;
752     atomic_notifier_chain_register(&panic_notifier_list,
753                        &wdog_dd->panic_blk);
754     mutex_init(&wdog_dd->disable_lock);   	
755     init_waitqueue_head(&wdog_dd->pet_complete);// åˆå§‹åŒ–å–‚ç‹—çš„ç­‰å¾…é˜Ÿåˆ—å¤´    	
756     wdog_dd->timer_expired = false;				// è®¾ç½®å–‚ç‹—å®šæ—¶å™¨è¶…æ—¶ä¸ºfalse
757     wdog_dd->user_pet_complete = true;			// ç”¨æˆ·ç©ºé—´ç­‰å¾…æ¡ä»¶é»˜è®¤ä¸ºçœŸ
758     wdog_dd->user_pet_enabled = false;			// ç”¨æˆ·ç©ºé—´å–‚ç‹—é»˜è®¤å¤±èƒ½
759     wake_up_process(wdog_dd->watchdog_task);	// å”¤é†’ä¹‹å‰åˆ›å»ºçš„å–‚ç‹—çº¿ç¨‹
760     init_timer(&wdog_dd->pet_timer);			// åˆå§‹åŒ–å”¤é†’å†…æ ¸å–‚ç‹—çº¿ç¨‹çš„å®šæ—¶å™¨
761     wdog_dd->pet_timer.data = (unsigned long)wdog_dd;
762     wdog_dd->pet_timer.function = pet_task_wakeup;	// å–‚ç‹—å®šæ—¶å™¨å®šæ—¶å¤„ç†å‡½æ•°ï¼Œä¸»è¦ç”¨æ¥å”¤é†’ç¡çœ åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šçš„å–‚ç‹—çº¿ç¨‹
763     wdog_dd->pet_timer.expires = jiffies + delay_time;	// å®šæ—¶å™¨çš„è§¦å‘æ—¶é—´æ˜¯å½“å‰æ—¶é—´ + 9.56 s,ä¹Ÿå°±æ˜¯9.56så”¤é†’pet_timnerå»å–‚ç‹—
764     add_timer(&wdog_dd->pet_timer);	// ä½¿èƒ½å–‚ç‹—å®šæ—¶å™¨ï¼Œ9.56sä¹‹åå»å”¤é†’å–‚ç‹—çº¿ç¨‹
765 
766     val = BIT(EN);		// 1 << 0
767     if (wdog_dd->wakeup_irq_enable)
768         val |= BIT(UNMASKED_INT_EN);	// 1 << 0 | 1 << 1
769     __raw_writel(val, wdog_dd->base + WDT0_EN);	// ä½¿èƒ½çœ‹é—¨ç‹—ä¸­æ–­ï¼ˆ0ä½å’Œ1ä½ï¼‰
770     __raw_writel(1, wdog_dd->base + WDT0_RST);	// çœ‹é—¨ç‹—å¤ä½,çœ‹é—¨ç‹—å®šæ—¶å™¨è¶…æ—¶ä¹‹å‰æ²¡æœ‰è¢«é‡ç½®åˆ™äº§ç”Ÿçœ‹é—¨ç‹—å®šæ—¶å™¨ä¸­æ–­ï¼Œè¿›å…¥wdog_ppi_barkä¸­æ–­å¤„ç†å‡½æ•°
771     wdog_dd->last_pet = sched_clock();			// è®¾ç½®æœ€è¿‘å–‚ç‹—çš„æ—¶é—´
772     wdog_dd->enabled = true;					// è®¾ç½®çœ‹é—¨ç‹—å·²ç»ä½¿èƒ½
773 
774     init_watchdog_sysfs(wdog_dd);				// åˆ›å»ºsysèŠ‚ç‚¹
775 
776     if (wdog_dd->irq_ppi)
777         enable_percpu_irq(wdog_dd->bark_irq, 0);	// åœ¨æ‰€æœ‰æ ¸ä¸Šä½¿èƒ½ğŸ•å«ä¸­æ–­
778     if (!ipi_en)
779         cpu_pm_register_notifier(&wdog_cpu_pm_nb);
780     dev_info(wdog_dd->dev, "MSM Watchdog Initialized\n");
781 }
782 
783 static const struct of_device_id msm_wdog_match_table[] = {
784     { .compatible = "qcom,msm-watchdog" },
785     {}
786 };
787 
788 static void dump_pdata(struct msm_watchdog_data *pdata)
789 {
790     dev_dbg(pdata->dev, "wdog bark_time %d", pdata->bark_time);
791     dev_dbg(pdata->dev, "wdog pet_time %d", pdata->pet_time);
792     dev_dbg(pdata->dev, "wdog perform ipi ping %d", pdata->do_ipi_ping);
793     dev_dbg(pdata->dev, "wdog base address is 0x%lx\n", (unsigned long)
794                                 pdata->base);
795 }   
796     
797 static int msm_wdog_dt_to_pdata(struct platform_device *pdev,
798                     struct msm_watchdog_data *pdata)
799 {  
    	// ä»platform_deviceä¸­è·å–è®¾å¤‡æ ‘çš„èŠ‚ç‚¹æŒ‡é’ˆ
800     struct device_node *node = pdev->dev.of_node;
801     struct resource *res;
802     int ret, cpu, num_scandump_sizes;
803     
    	// é€šè¿‡èŠ‚ç‚¹"wdt-base"è·å–çœ‹é—¨ç‹—å¯„å­˜å™¨çš„åœ°å€ä¿¡æ¯<èµ·å§‹ç‰©ç†åœ°å€ï¼šå æ®ç‰©ç†åœ°å€å¤§å°>
    	// è®¾å¤‡æ ‘é‡Œé¢åŒ…å«wdt-baseé”®å€¼çš„èŠ‚ç‚¹ä¸­çš„regé”®ä»£è¡¨è¯¥èŠ‚ç‚¹åŒ…å«çš„IO MEMä¿¡æ¯
804     res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "wdt-base");
805     if (!res)
806         return -ENODEV;
    	// è®¾ç½®msm_watchdog_dataçš„sizeæˆå‘˜ï¼Œä»£è¡¨åˆ°æ—¶å€™è¦å†™çœ‹é—¨å¤Ÿå¯„å­˜å æ®çš„ç‰©ç†åœ°å€ç©ºé—´å¤§å°
    	// resource_sizeå¯ä»¥è·å–IO_MEMçš„å¤§å°
807     pdata->size = resource_size(res);
    	// è®¾ç½®çœ‹é—¨ç‹—å¯„å­˜å™¨çš„ç‰©ç†åœ°å€<å¼€å§‹åœ°å€>ï¼Œè¦å†™ä¸€ç»„å¯„å­˜å™¨ï¼Œéœ€è¦çŸ¥é“å¯„å­˜å™¨åŸºåœ°å€+åç§»
808     pdata->phys_base = res->start;
    	// å‘Šè¯‰å†…æ ¸è¦ä½¿ç”¨pdata->phys_baseå¼€å§‹pdata->sizeå¤§å°çš„IOåœ°å€ç©ºé—´ï¼Œå†…éƒ¨åªåšäº†æ£€æµ‹æ˜¯å¦èƒ½ä½¿ç”¨è¯¥åœ°å€å¼€å§‹å¯¹åº”çš„é•¿åº¦ï¼Œå¹¶æ²¡æœ‰æ­£çœŸçš„ä½¿ç”¨
809     if (unlikely(!(devm_request_mem_region(&pdev->dev, pdata->phys_base,
810                            pdata->size, "msm-watchdog")))) {
811     
812         dev_err(&pdev->dev, "%s cannot reserve watchdog region\n",
813                                 __func__);
814         return -ENXIO;
815     }
    	// æŠŠä¸Šé¢æ£€æµ‹èƒ½å®‰å…¨ä½¿ç”¨çš„IOåœ°å€å¯¹åº”çš„åŒºåŸŸåˆ›å»ºé¡µè¡¨ï¼Œè¿”å›å†…å­˜è™šæ‹Ÿåœ°å€ï¼ŒARMä¸èƒ½ç›´æ¥è®¿é—®IOç‰©ç†åœ°å€ï¼Œéœ€è¦æ˜ å°„åˆ°å†…å­˜åœ°å€ç©ºé—´
816     pdata->base  = devm_ioremap(&pdev->dev, pdata->phys_base,
817                             pdata->size);
818     if (!pdata->base) { 
819         dev_err(&pdev->dev, "%s cannot map wdog register space\n",
820                 __func__);
821         return -ENXIO;
822     }
823     
    	// NULLæ“ä½œ
824     res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
825                        "wdt-absent-base");
826     if (res) {	// ä¸ä¼šè¿›
827         pdata->wdog_absent_base  = devm_ioremap(&pdev->dev, res->start,
828                              resource_size(res));
829         if (!pdata->wdog_absent_base) {
830             dev_err(&pdev->dev,
831                 "cannot map wdog absent register space\n");
832             return -ENXIO;
833         }
834     } else {
835         dev_info(&pdev->dev, "wdog absent resource not present\n");
836     }
837 	
    	// ä»platform_deviceä¸­è·å–ä¸­æ–­å·0çš„ä¸­æ–­ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯ğŸ•å«ä¸­æ–­å·
838     pdata->bark_irq = platform_get_irq(pdev, 0);
    	// ä»platform_deviceä¸­è·å–ä¸­æ–­å·1çš„ä¸­æ–­ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯ğŸ•å’¬ä¸­æ–­å·
839     pdata->bite_irq = platform_get_irq(pdev, 1);
    	// ä»è®¾å¤‡æ ‘èŠ‚ç‚¹æŒ‡é’ˆè·å–é”®"qcom,bark-time"å¯¹åº”çš„å€¼å†™å…¥pdata->bark_time
    	// ä¹Ÿå°±æ˜¯ğŸ•å«æ—¶é—´å€¼ï¼š11000ms = 11s
840     ret = of_property_read_u32(node, "qcom,bark-time", &pdata->bark_time);
841     if (ret) {
842         dev_err(&pdev->dev, "reading bark time failed\n");
843         return -ENXIO;
844     }
    	// å–‚ğŸ•æ—¶é—´ï¼š9360ms = 9.36s
845     ret = of_property_read_u32(node, "qcom,pet-time", &pdata->pet_time);
846     if (ret) {
847         dev_err(&pdev->dev, "reading pet time failed\n");
848         return -ENXIO;
849     }
    	// æŸ¥çœ‹è®¾å¤‡æ ‘èŠ‚ç‚¹ä¸­æ˜¯å¦å­˜åœ¨é”®"qcom,ipi-ping"ï¼Œè¯¥å€¼æŒ‡ç¤ºå–‚ç‹—æ—¶æ˜¯å¦pingå…¶ä»–CPU
    	// è¿™é‡Œçš„çœ‹é—¨ç‹—åœ¨å–‚ç‹—æ—¶ä¼špingæ‰€æœ‰çš„CPUï¼Œä¿è¯æ‰€æœ‰CPUéƒ½åœ¨æ­£å¸¸è¿è¡Œ
850     pdata->do_ipi_ping = of_property_read_bool(node, "qcom,ipi-ping");
    	// ğŸ•å«æ—¶é—´è·å–å¤±è´¥ï¼Œç›´æ¥è¿”å›é”™è¯¯ï¼Œé©±åŠ¨probeå¤±è´¥
851     if (!pdata->bark_time) {
852         dev_err(&pdev->dev, "%s watchdog bark time not setup\n",
853                                 __func__);
854         return -ENXIO;
855     }
856     if (!pdata->pet_time) {
857         dev_err(&pdev->dev, "%s watchdog pet time not setup\n",
858                                 __func__);
859         return -ENXIO;
860     }
    	// ä»è®¾å¤‡æ ‘å‡ ç‚¹è·å–ä¼‘çœ å”¤é†’æ—¶æ˜¯å¦è‡ªåŠ¨åœæ­¢å’Œå¯åŠ¨çœ‹é—¨ç‹—
    	// è¿™é‡Œä¼‘çœ å”¤é†’æ—¶ä¼šåœæ­¢å’Œå¯åŠ¨çœ‹é—¨ç‹—ï¼Œé¿å…ç³»ç»Ÿä¼‘çœ é€ æˆçœ‹é—¨ç‹—ğŸ•å’¬ç„¶åé‡å¯ç³»ç»Ÿ
861     pdata->wakeup_irq_enable = of_property_read_bool(node,
862                              "qcom,wakeup-enable");
863 	// scandumpçš„å€¼æœ‰8ä¸ªï¼Œæ¯ä¸ªcpuå¯¹åº”ä¸€ä¸ªï¼ˆè¿™é‡Œæ˜¯8æ ¸ï¼‰
864     num_scandump_sizes = of_property_count_elems_of_size(node,
865                             "qcom,scandump-sizes",
866                             sizeof(u32));
867     if ((num_scandump_sizes < 0) || ((num_scandump_sizes != 1) &&
868                 (num_scandump_sizes != NR_CPUS))) {
869         dev_info(&pdev->dev, "%s scandump sizes property not correct\n",
870             __func__);
871     } else if (num_scandump_sizes == 1) {
872         if (of_property_read_u32(node, "qcom,scandump-sizes",
873                      &pdata->scandump_size))
874             dev_info(&pdev->dev,
875                  "No need to allocate memory for scandumps\n");
876     } else {
877         for_each_cpu(cpu, cpu_present_mask)
878             of_property_read_u32_index(node, "qcom,scandump-sizes",
879                            cpu,
880                     &pdata->cpu_scandump_sizes[cpu]);
881     }
882 
    	// åˆ¤æ–­ğŸ•å«ä¸­æ–­æ˜¯å¦æ¯CPUå…±äº«
883     pdata->irq_ppi = irq_is_percpu(pdata->bark_irq);
884     dump_pdata(pdata);
885     return 0;
886 }
887 
888 static int msm_watchdog_probe(struct platform_device *pdev)
889 {
890     int ret;
891     struct msm_watchdog_data *wdog_dd;
892     struct md_region md_entry;
893 
894     if (!pdev->dev.of_node || !enable)
895         return -ENODEV;
896     wdog_dd = kzalloc(sizeof(struct msm_watchdog_data), GFP_KERNEL);
897     if (!wdog_dd)
898         return -EIO;
    	// ä»è®¾å¤‡æ ‘è§£æçœ‹é—¨ç‹—å¯„å­˜å™¨ã€ä¸­æ–­ã€å–‚ç‹—ã€ç‹—å«ç­‰ä¿¡æ¯
899     ret = msm_wdog_dt_to_pdata(pdev, wdog_dd);
900     if (ret)
901         goto err;
902 
903     wdog_data = wdog_dd;
904     wdog_dd->dev = &pdev->dev;
    	// å°†struct msm_watchdog_data *wdog_dd è®¾ç½®åˆ°pdevçš„ç§æœ‰åŸŸ
905     platform_set_drvdata(pdev, wdog_dd);
906     cpumask_clear(&wdog_dd->alive_mask);
    	// åˆ›å»ºçœ‹é—¨ç‹—å¯¹åº”çš„å†…æ ¸çº¿ç¨‹ï¼Œå‚æ•°æ˜¯wdog_ddï¼Œçº¿ç¨‹åå­—æ˜¯msm_watchdog
907     wdog_dd->watchdog_task = kthread_create(watchdog_kthread, wdog_dd,
908             "msm_watchdog");
909     if (IS_ERR(wdog_dd->watchdog_task)) {
910         ret = PTR_ERR(wdog_dd->watchdog_task);
911         goto err;
912     }
913     init_watchdog_data(wdog_dd);
914 
915     /* Add wdog info to minidump table */
    	// åœ¨minidumpè¡¨ä¸­æ·»åŠ msm_watchdog_dataç»“æ„ä½“çš„ä¿¡æ¯
916     strlcpy(md_entry.name, "KWDOGDATA", sizeof(md_entry.name));
917     md_entry.virt_addr = (uintptr_t)wdog_dd;
918     md_entry.phys_addr = virt_to_phys(wdog_dd);
919     md_entry.size = sizeof(*wdog_dd);
920     if (msm_minidump_add_region(&md_entry))
921         pr_info("Failed to add Watchdog data in Minidump\n");
922 
923     return 0;
924 err:
925     kzfree(wdog_dd);
926     return ret;
927 }
928 
929 static const struct dev_pm_ops msm_watchdog_dev_pm_ops = {
930     SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(msm_watchdog_suspend, msm_watchdog_resume)
931 };
932 
933 static struct platform_driver msm_watchdog_driver = {
934     .probe = msm_watchdog_probe,		// platformé©±åŠ¨æ³¨å†Œä¹‹åå’Œè®¾å¤‡æ ‘ä¸­ä¿¡æ¯åŒ¹é…æˆåŠŸä¼šè°ƒç”¨è¯¥å‡½æ•°
935     .remove = msm_watchdog_remove,
936     .driver = {
937         .name = MODULE_NAME,
938         .owner = THIS_MODULE,
939         .pm = &msm_watchdog_dev_pm_ops,			// çœ‹é—¨ç‹—ç”µæºç®¡ç†
940         .of_match_table = msm_wdog_match_table,	// å’Œè®¾å¤‡æ ‘compatibleèŠ‚ç‚¹åŒ¹é…
941     },
942 };
943 
944 static int init_watchdog(void)
945 {
    	// æ³¨å†Œplatfromé©±åŠ¨
946     return platform_driver_register(&msm_watchdog_driver);
947 }
948 
949 pure_initcall(init_watchdog);
950 MODULE_DESCRIPTION("MSM Watchdog Driver");
951 MODULE_LICENSE("GPL v2");
```

